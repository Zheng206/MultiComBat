% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/diagnostics.R
\name{pca_prep}
\alias{pca_prep}
\title{PCA prep for batch diagnostics (single or multiple measurements)}
\usage{
pca_prep(
  bat,
  data,
  covar,
  model,
  formula = NULL,
  ref.batch = NULL,
  bat_adjust = TRUE,
  ...
)
}
\arguments{
\item{bat}{Either a factor of length \emph{n} (univariate case), or a list of \emph{m}
factors (one per measurement) of length \emph{n} (multivariate).}

\item{data}{Either an numeric matrix/data frame, or a list of \emph{m}
such matrices/data frames (matching \code{bat}).}

\item{covar}{Data frame of covariates. \code{NULL} for a null model,
or a list of data frames if \code{data} is a list.}

\item{model}{Modeling function that accepts \code{formula} and \code{data}
(e.g., \code{\link[stats:lm]{stats::lm()}}, \code{\link[mgcv:gam]{mgcv::gam()}}, \code{\link[lme4:lmer]{lme4::lmer()}}).}

\item{formula}{RHS formula for covariates (do \strong{not} include batch; it is
added internally when batch adjustment is enabled).}

\item{ref.batch}{Optional reference batch level (forwarded to internal
modeling, if applicable).}

\item{bat_adjust}{Logical; if \code{TRUE} (default) include batch dummies in the
per-feature model via \code{model_fitting()} (same behavior as in harmonization).}

\item{...}{Additional arguments forwarded to \code{model}.}
}
\value{
\itemize{
\item \strong{If \code{data} is a list (multivariate)}: a list with
\describe{
\item{F_list}{List of length \emph{m}; each element is an \eqn{n \times r_t} PCA score
matrix from the within-measurement PCA on additive residuals.}
\item{G}{\eqn{n \times r_concat} matrix of scores from a second PCA on the
column-bound \code{F_list} (shared subject score space).}
\item{bat}{The input list of batch factors (returned for convenience).}
}
\item \strong{If \code{data} is a matrix/data.frame (univariate)}: a list with
\describe{
\item{F_t}{\eqn{n \times r} PCA score matrix from the residual PCA.}
\item{bat}{The input batch factor (returned for convenience).}
}
}
}
\description{
Fits per-feature models (via \code{\link[=diag_model_gen]{diag_model_gen()}} + \code{\link[=diag_model_summary]{diag_model_summary()}}),
extracts \strong{additive residuals}, and runs PCA to obtain score matrices for
visualization/diagnostics:
}
\details{
\itemize{
\item \strong{Multivariate input} (\code{data} is a list of length \emph{m}): run PCA within
each measurement to get \code{F_list} (per-measurement scores), then concatenate
scores and run a second PCA to get the shared score space \code{G}.
\item \strong{Univariate input} (\code{data} is a matrix/data.frame): run a single PCA on
the residual matrix to get \code{F_t}.
}

Residuals are the \strong{additive} residuals produced by
\code{\link[=diag_model_summary]{diag_model_summary()}}, i.e., the data after removing non-batch fixed effects
(and batch dummies if \code{bat_adjust = TRUE}).
}
\examples{
set.seed(1)
n <- 40; G <- 10
X <- matrix(rnorm(n*G), n, G); colnames(X) <- paste0("g",1:G)
b <- factor(rep(LETTERS[1:2], each = n/2))
# Univariate (single measurement)
pp1 <- pca_prep(b, X, covar = NULL, model = stats::lm, formula = y ~ 1)
str(pp1$F_t)

# Multivariate (two measurements)
Y1 <- X + matrix(rnorm(n*G, sd=.3), n, G)
Y2 <- X + matrix(rnorm(n*G, sd=.5), n, G)
bats <- list(b, b)
pp2 <- pca_prep(bats, list(Y1, Y2), covar = list(NULL,NULL),
                model = stats::lm, formula = y ~ 1)
lapply(pp2$F_list, dim); dim(pp2$G)

}
\seealso{
\code{\link[=diag_model_gen]{diag_model_gen()}}, \code{\link[=diag_model_summary]{diag_model_summary()}}, \code{\link[=pca_plot]{pca_plot()}}
}
