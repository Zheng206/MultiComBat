% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/help_func.R
\name{robust_matrix_solver}
\alias{robust_matrix_solver}
\title{Robust matrix inversion/solve with fallbacks}
\usage{
robust_matrix_solver(
  mat,
  method = c("auto", "solve", "pseudoinverse", "qr", "chol")
)
}
\arguments{
\item{mat}{Numeric matrix (square for a true inverse).}

\item{method}{One of \code{"auto"}, \code{"solve"}, \code{"pseudoinverse"},
\code{"qr"}, or \code{"chol"}. With \code{"auto"} (default), uses
\code{MASS::ginv} when \code{kappa(mat)} is large; otherwise \code{solve()}.}
}
\value{
A matrix approximating \eqn{A^{-1}}. For rectangular \code{mat} and
methods that allow it, this is a Mooreâ€“Penrose pseudoinverse.
}
\description{
Attempts to invert a matrix (or solve \eqn{A X = I}) using several methods,
with an automatic choice based on conditioning and a safe pseudoinverse
fallback. Useful when covariance/precision matrices may be ill-conditioned.
}
\details{
If the chosen method errors, the function warns and returns
\code{MASS::ginv(mat + diag(1e-8, nrow(mat)))} as a regularized pseudoinverse.
The \code{"qr"} method computes an inverse by solving \eqn{A X = I} via QR;
the \code{"chol"} method uses \code{chol2inv(chol(A))} and requires SPD input.
}
\examples{
set.seed(1)
A <- crossprod(matrix(rnorm(16), 4, 4))
invA <- robust_matrix_solver(A, method = "auto")
max(abs(invA \%*\% A - diag(4)))

# Ill-conditioned example falls back to pseudoinverse
B <- crossprod(cbind(1, 1 + 1e-10, rnorm(4)))
invB <- robust_matrix_solver(B)

}
