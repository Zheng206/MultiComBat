% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/help_func.R
\name{multi_matrix_transform}
\alias{multi_matrix_transform}
\alias{multi_matrix_transform_inverse}
\title{Reshape a single feature across measurements (and back)}
\usage{
multi_matrix_transform(Z_list, g)

multi_matrix_transform_inverse(Zi_matrix, g_name)
}
\arguments{
\item{Z_list}{A list of length \eqn{m}. Each element is an \eqn{n \times G}
numeric matrix/data frame (rows = samples, columns = features), all with the
same \eqn{n} and \eqn{G}, and columns ordered consistently.}

\item{g}{Integer column index of the feature to extract (1â€¦\eqn{G}).}

\item{Zi_matrix}{An \eqn{m \times n} numeric matrix produced by
\code{multi_matrix_transform()}.}

\item{g_name}{Character scalar used as the single column name for each
reconstructed \eqn{n \times 1} data frame.}
}
\value{
\code{multi_matrix_transform()} returns an \eqn{m \times n} numeric
matrix whose \eqn{i}-th row is the \eqn{g}-th column of \eqn{Z_i}.

\code{multi_matrix_transform_inverse()} returns a list of length
\eqn{m}; each element is an \eqn{n \times 1} data frame containing the
corresponding row of \code{Zi_matrix}, with column name \code{g_name}.
}
\description{
Helpers to (a) extract one feature/column \eqn{g} from a list of matrices
\eqn{Z_1,\dots,Z_m} and stack it into an \eqn{m \times n} matrix
(rows = measurements, cols = samples), and (b) invert that operation.
}
\examples{
set.seed(1)
m <- 3; n <- 5; G <- 4
Z_list <- lapply(1:m, function(i) matrix(rnorm(n*G), n, G,
                   dimnames = list(NULL, paste0("feat", 1:G))))
Zi <- multi_matrix_transform(Z_list, g = 2)   # m x n
dim(Zi)

g_list <- multi_matrix_transform_inverse(Zi, g_name = "feat2")
length(g_list); nrow(g_list[[1]])

}
\seealso{
\code{\link{multi_matrix_transform_inverse}}
}
